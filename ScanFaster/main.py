#!/usr/bin/python3

import argparse
import sys
import socket
from datetime import datetime
import timeit
import struct
import time
import os
import signal
import threading
import subprocess
from queue import Queue
import csv
import scapy.all as scapy
import re
from loguru import logger


parser = argparse.ArgumentParser()
parser.add_argument("-v","--verbose",help="Para Ver modo depuracion -v ",action="store_true")
args =  parser.parse_args()


VERV=False
path_log ="log"
if not os.path.exists(path_log):
    os.mkdir(path_log)

logger.add(sys.stdout, format="{time} {level} {message}" , filter="my_module", level="INFO")
filename= "log/ScanFaster_" + datetime.now().strftime("%d_%m_%Y") + ".log"
logger.add(filename)

if args.verbose:
    VERV=True
    print("Modo Depuracion Activada")
else:
    VERV=False
    print("Modo Sin Depuracion")



''' Funciones Generales  '''
# Print iterations progress
@logger.catch
def printProgressBar (iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = '█', printEnd = "\r"):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        decimals    - Optional  : positive number of decimals in percent complete (Int)
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
        printEnd    - Optional  : end character (e.g. "\r", "\r\n") (Str)
        https://stackoverflow.com/questions/3173320/text-progress-bar-in-terminal-with-block-characters?noredirect=1&lq=1
    """
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + '-' * (length - filledLength)
    print(f'\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)
    # Print New Line on Complete
    if iteration == total: 
        print()

@logger.catch
def _printBanner():
    p1=" ____                  _____         _              _____ _____   _ "
    p2="/ ___|  ___ __ _ _ __ |  ___|_ _ ___| |_ ___ _ __  |  ___|  ___| | |"
    p3="\___ \ / __/ _` | '_ \| |_ / _` / __| __/ _ \ '__| | |_  | |_ _  | |"
    p4=" ___) | (_| (_| | | | |  _| (_| \__ \ ||  __/ |    |  _| |  _| |_| |"
    p5="|____/ \___\__,_|_| |_|_|  \__,_|___/\__\___|_|    |_|   |_|  \___/  2022"
    print(p1)
    print(p2)
    print(p3)
    print(p4)
    print(p5)
    if(VERV):logger.success("Iniciando Programa Correctamente Modo Depuración")
'''Fin  Funciones Generales  '''


'''Inicio Sniffer '''
# Cabecera
magic_number = 2712847316  #  0xa1b2c3d4 (identical) or 0xd4c3b2a1 (swapped) int(str("a1b2c3d4"),16) ----> 2712847316
major_number = 2  # El número de versión de este formato de archivo (Version actual es la 2.4) -----> 2
minor_number = 4  # El número de versión de este formato de archivo (Versión actual es la 2.4) -----> 4
gmt_yo_local = 0
acc_timestamp = 0
max_len = 65535   #  "Muestreo de largo" para la captura típica es de 65535
dl_type = 1
# Definimos la clase Pcap para la generción de objetos 
class Pcap:
    def __init__(self, filename, link_type=dl_type):
        if(VERV):logger.success("Iniciando Sniffer {}",)
        self.pcap_file = open(filename, 'wb')
        # Ver https://docs.python.org/3/library/struct.html#format-characters
        self.pcap_file.write(struct.pack('@ I H H i I I I ', magic_number, major_number, minor_number, gmt_yo_local, acc_timestamp, max_len, link_type))
    
    def writelist(self, data=[]):
        for i in data: # Considerar tabulado en python
            self.write(i)

        return

    def write(self, data):
        ts_sec, ts_usec = map(int, str(time.time()).split('.'))
        length = len(data)
        #VER https://docs.python.org/3/library/struct.html#format-characters
        self.pcap_file.write(struct.pack('@ I I I I', ts_sec, ts_usec, length, length))
        self.pcap_file.write(data)

    def close(self):
        self.pcap_file.close()
        if(VERV):logger.success("Proceso finalizado correctamente")

@logger.catch
def _sniffing():
    # Creación de un socket con constructor default.
    try:
        sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(3))
    except socket.error:
        print('El socket no se puedo crear, use privilegios de root o revise que la tarjeta de red esté en funcionamiento')
        sys.exit(1)

    '''Crea directorio de Salida outputSniffer '''
    if(os.path.isdir('outputSniffer')):
        pass
    else:
        os.mkdir("outputSniffer")

    tmstmp = datetime.today().strftime('%Y_%m_%d_%H_%M_%S')
    nameFile ='outputSniffer/Salida'+ str(tmstmp) + '.pcap'
    # invoca a la clase Pcap
    mypcap = Pcap(nameFile)

    contador = 0
    # Initial call to print 0% progress
    printProgressBar(0, 1000, prefix = 'Progress:', suffix = 'Complete', length = 50)

    while (contador <1000):

        # Escuchamos
        pkt=sock.recvfrom(65565)
        
        # escribimos
        mypcap.write(pkt[0])

        # flush, recargamos, actualizamos... la data en el archivo
        mypcap.pcap_file.flush()
        contador += 1
        printProgressBar(contador , 1000, prefix = 'Progress:', suffix = 'Complete', length = 50)
        ##print(contador/100,'%')

    # Cerramos el archivo
    mypcap.close()
    print(".....................")
    print("Proceso finalizado")
    _mainMenu()
'''fin sniffer '''

''' inicio scanPorts '''
# Funcion Principal de scanPorts
@logger.catch
def _scanPortThread():
   socket.setdefaulttimeout(0.30)
   print_lock = threading.Lock()
   discovered_ports = []
   if(VERV):logger.success("Iniciando ScanPorts modo Depuracion")
   # Welcome Banner
   print("-" * 60)
   print("        Scanner de puertos          ")
   ##print("                       Version 1.0.7                    ")
   ##print("                   A project by The Mayor               ")
   print("-" * 60)
   time.sleep(1)
   target = input("Ingresa la IP o URL: ")
   error = ("Dato Invalido")
   try:
      t_ip = socket.gethostbyname(target)
   except (UnboundLocalError, socket.gaierror):
      print("\n[-]Invalid format. Please use a correct IP or web address[-]\n")
      sys.exit()
   #Banner
   fecha= datetime.today().strftime('%Y_%m_%d_%H_%M_%S')
   print("-" * 60)
   print("Scanning target "+ t_ip)
   print("Time started: "+ str(datetime.now()))
   print("-" * 60)
   t1 = datetime.now()
   @logger.catch
   def _savePorts(listPorts,target):
   
      lt = [int(x) for x in listPorts]
      nFile ='outputPorts/'+target+'__'+fecha +'.txt'
      # open file in write mode
      if(os.path.isdir('outputPorts')):
         pass
      else:
         os.mkdir("outputPorts")



      with open(nFile, 'w') as fp:
            for item in lt:
               # write each item on a new line
               fp.write("%s\n" % item)
            fp.close()          
   @logger.catch
   def portscan(port):

      s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      
      try:
         portx = s.connect((t_ip, port))
         with print_lock:
            print("Port {} is open".format(port))
            discovered_ports.append(str(port))
         portx.close()

      except (ConnectionRefusedError, AttributeError, OSError):
         pass

   @logger.catch
   def threader():
      while True:
         worker = q.get()
         portscan(worker)
         q.task_done()
   
   q = Queue()
   
   #startTime = time.time()
   
   for x in range(200):
      t = threading.Thread(target = threader)
      t.daemon = True
      t.start()

   for worker in range(1, 65536):  ##range(1, 65536):
      q.put(worker)

   q.join()

   t2 = datetime.now()
   total = t2 - t1
   print("Port scan completed in "+str(total))
   print("-" * 60)
   print("Threader3000 recommends the following Nmap scan:")
   print("*" * 60)
   print("nmap -p{ports} -sV -sC -T4 -Pn -oA {ip} {ip}".format(ports=",".join(discovered_ports), ip=target))
   print("*" * 60)
   pathFile =target +'__'+fecha
   nmap = "nmap -p{ports} -sV -sC -T4 -Pn -oA {path} {ip}".format(ports=",".join(discovered_ports),path=pathFile, ip=target)
   t3 = datetime.now()
   total1 = t3 - t1
   
   '''
   Funcion para guardar los puertos encontrados en el directorio output
   procesa lista y la guarda en un archivo scanPort mas nombre del target y la fecha
   '''
   _savePorts(discovered_ports,target)
  
   @logger.catch
   def automate():
      choice = '0'
      while choice =='0':
         print("Would you like to run Nmap or quit to terminal?")
         print("-" * 60)
         print("1 = Run suggested Nmap scan")
         print("2 = Run another Threader3000 scan")
         print("3 = Exit to terminal")
         print("-" * 60)
         choice = input("Option Selection: ")
         if choice == "1":
            try:
               print(nmap)
               os.chdir('outputPorts') #target
               os.mkdir(pathFile) #target
               os.chdir(pathFile)
               os.system(nmap)
               os.chdir(PTS)
               #convert = "xsltproc "+target+".xml -o "+target+".html"
               #os.system(convert)
               t3 = datetime.now()
               total1 = t3 - t1
               print("-" * 60)
               print("Combined scan completed in "+str(total1))
               print("Press enter to quit...")
               _mainMenu()

            except FileExistsError as e:
               print(e)
               exit()
         elif choice =="2":
            _scanPortThread()
         elif choice =="3":
            sys.exit()
         elif choice =="4":
            return 1
         else:
            print("Please make a valid selection")
            automate()
   automate()
''' fin scanPorts '''

'''Inicio scanHost '''
@logger.catch
def _saveHost(listHost):
    fecha= datetime.today().strftime('%Y_%m_%d_%H_%M_%S')
    nFile ='outputHost/host__'+fecha +'.txt'
    if(VERV):logger.success("Guardando informacion en:  {}",nFile)
    # open file in write mode
    if(os.path.isdir('outputHost')):
        pass
    else:
        os.mkdir("outputHost")



    keys = listHost[0].keys()

    with open(nFile, 'w', newline='') as output_file:
        dict_writer = csv.DictWriter(output_file, keys)
        dict_writer.writeheader()
        dict_writer.writerows(listHost) 
@logger.catch
def scan(ip):
    if(VERV):logger.success("Iniciando Scaneo ip: {}", ip)
    arp_req_frame = scapy.ARP(pdst = ip)

    broadcast_ether_frame = scapy.Ether(dst = "ff:ff:ff:ff:ff:ff")
    
    broadcast_ether_arp_req_frame = broadcast_ether_frame / arp_req_frame

    answered_list = scapy.srp(broadcast_ether_arp_req_frame, timeout = 1, verbose = False)[0]
    result = []
    for i in range(0,len(answered_list)):
        client_dict = {"ip" : answered_list[i][1].psrc, "mac" : answered_list[i][1].hwsrc}
        result.append(client_dict)

    return result

@logger.catch 
def display_result(result):
    print("-----------------------------------\nIP Address\tMAC Address\n-----------------------------------")
    for i in result:
        print("{}\t{}".format(i["ip"], i["mac"]))
    
    if(VERV):logger.success("Proceso Finalizado")

@logger.catch
def validaRed(ip):
    if(VERV):logger.success("Validando Formato de Ip")
    #res =re.match(r'^([0-9]{3}\.|[0-9]{2}\.|[0-9]{1}\.)([0-9]{3}\.|[0-9]{2}\.|[0-9]{1}\.)([0-9]{3}|[0-9]{2}|[0-9])',ip)
    validip = re.match(r"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/[0-9]|\/[0-9]{2})$",ip)
    if validip is None:
        return  False
    else:
        #print(validip)
        return True

@logger.catch  
def _scanHost():
    if(VERV):logger.success("Iniciando Scanneo de HOST")
    red = input("Ingresa la Red y mascara ej: 192.168.1.1/24 ***** :  ")
    if validaRed(red):
        scanned_output = scan(red)
        _saveHost(scanned_output)
        display_result(scanned_output)
        print("Espera unos Segundos")
        printProgressBar(0, 1000, prefix = 'Progress:', suffix = 'Complete', length = 50)
        contador=1
        while (contador <1000):
            contador += 1
            printProgressBar(contador , 1000, prefix = 'Progress:', suffix = 'Complete', length = 50)
        _mainMenu()
    else:
        print("debe ingresar en el formato indicado")
        _scanHost()

'''Fin scanHost'''

@logger.catch
def _mainMenu():
    
    choice = '0'
    while choice =='0':
        _printBanner()
        print("----" * 40)
        print("1 = scan Host")
        print("2 = scan Port")
        print("3 = Sniffer por Seg")
        print("4 = Salir a la terminal")
        print("----" * 40)
        print("----" * 40)
        print(" ")
        choice = input("Ingresa tu opción ")
        if choice == "1":
            subprocess.call('clear', shell=True)
            try:
                ## escane de Host
                _scanHost()
                print("-" * 60)
            except FileExistsError as e:
                print(e)
                exit()
        elif choice =="2":
            subprocess.call('clear', shell=True)
            ## escaneo de puertos scanPort
            _scanPortThread()
        elif choice =="3":
            subprocess.call('clear', shell=True)
            ## sniffer
            _sniffing()
            
        elif choice =="4":
            sys.exit()
        else:
            subprocess.call('clear', shell=True)
            print("Ingrese una Opción valida")
            _mainMenu()

if __name__ == '__main__':
   try:
      PTS = os.path.abspath(os.getcwd())
      _mainMenu()
   except KeyboardInterrupt:
      print("\nGoodbye!")
      quit()


